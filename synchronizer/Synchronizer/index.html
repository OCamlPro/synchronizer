<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Synchronizer (synchronizer.Synchronizer)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">synchronizer</a> &#x00BB; Synchronizer</nav><header class="odoc-preamble"><h1>Module <code><span>Synchronizer</span></code></h1><p>This module offers a primitive which allows several threads to synchronize &quot;getting&quot; and &quot;writing&quot; work units to a common state keeper.</p><p>The main idea of this module, is that it allows one to (more) easily go from a sequential algorithm to a parallel one.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#&quot;get-work-to-do/write-work-done&quot;-sequential-algorithms">&quot;Get-work-to-do/write-work-done&quot; sequential algorithms</a></li><li><a href="#turning-it-into-a-parallel-algorithm">Turning it into a parallel algorithm</a><ul><li><a href="#adding-&quot;work-in-progress&quot;-semantics-to-the-work-pool">Adding &quot;work in progress&quot; semantics to the work pool</a></li><li><a href="#creating-a-synchronizer">Creating a synchronizer</a></li><li><a href="#the-notion-of-pledges">The notion of pledges</a></li><li><a href="#rewriting-the-main-loop">Rewriting the main loop</a></li></ul></li></ul></nav></div><div class="odoc-content"><h3 id="&quot;get-work-to-do/write-work-done&quot;-sequential-algorithms"><a href="#&quot;get-work-to-do/write-work-done&quot;-sequential-algorithms" class="anchor"></a>&quot;Get-work-to-do/write-work-done&quot; sequential algorithms</h3><p>The class of algorithms that this module helps make parallel are those that are built around a central &quot;work to do&quot; structure, and in a loop:</p><ol><li><i>get</i> one work unit from the &quot;work to do&quot; pool</li><li>Process it</li><li>During processing, discover updates to <i>write</i> to the pool, and do so</li><li>End the processing of this work unit</li></ol><p>Most, if not all algorithm built around queues, stacks, and priority queues can be formulated this way: <i>getting</i> a work unit is simply popping from the queue, and <i>writing</i> updates is simply pushing new work units. However, this algorithm is more general: for example the work pool could be a tree, <i>getting</i> a new unit of work would entail some search of the tree, and <i>writing</i> updates would be adding nodes to the tree, or marking existing ones.</p><h3 id="turning-it-into-a-parallel-algorithm"><a href="#turning-it-into-a-parallel-algorithm" class="anchor"></a>Turning it into a parallel algorithm</h3><h4 id="adding-&quot;work-in-progress&quot;-semantics-to-the-work-pool"><a href="#adding-&quot;work-in-progress&quot;-semantics-to-the-work-pool" class="anchor"></a>Adding &quot;work in progress&quot; semantics to the work pool</h4><p>The first step to turn this sequential algorithm into a parallel one is to add a notion of &quot;ongoing work&quot; to our central data structure. When sequential, one cannot observe a work pool where some items are still being worked on, because each (sequential) iteration of the loop is the processing of exactly one work unit. Once parallel, the work pool should also (in most cases) encode a notion of the work tasks being processed.</p><h4 id="creating-a-synchronizer"><a href="#creating-a-synchronizer" class="anchor"></a>Creating a synchronizer</h4><p>Once it is done, the user should write two closures (notice that these two closures do not take the work pool as arguments, because they are closure, it is directly part of their environment).</p><pre class="language-ocaml"><code>  getter: unit -&gt; get option</code></pre><p><code>getter</code> returns the next work unit, or None if their is (currently) no work unit to be scheduled. This is only <i>currently</i> because another thread may later enqueue some new work unit. The work pool does not have to deal with how many threads are still live this is done by the synchronizer itself (it is actually its main added value). The type <code>get</code> is the one of the work unit.</p><pre class="language-ocaml"><code>  writer: write -&gt; Condition.t -&gt; unit</code></pre><p><code>writer</code> takes an update to apply to the work pool, of type <code>write</code>, and a condition variable. If this update makes a single new work unit available, the condition variable should be signaled with <code>Condition.signal</code>. If more than one unit of work are made available, it should be broadcast-signaled with <code>Condition.broadcast</code>.</p><p>Finally, one can create the synchronizer with</p><pre class="language-ocaml"><code>  synchronizer = init getter writer</code></pre><h4 id="the-notion-of-pledges"><a href="#the-notion-of-pledges" class="anchor"></a>The notion of pledges</h4><p>As mentioned before, when going to non-sequential, the main difference is that work can now be &quot;on going&quot;: threads may hence still <i>write</i> updated while processing a work unit. Knowing whether a work pool is empty is hence not sufficient to know whether or not one should stop the loop: we must also know whether someone else may re-enqueue new work. The synchronizer supports this via <i>pledges</i>. A <i>pledge</i> is made to indicate that new <i>updates</i> may be done to the work pool. Each started pledge must be ended once the current work unit won't lead to more updates (corresponding to the end of the loop in the sequential algorithm).</p><h4 id="rewriting-the-main-loop"><a href="#rewriting-the-main-loop" class="anchor"></a>Rewriting the main loop</h4><p>The loop outline above now becomes:</p><ol><li><i>get</i> one work unit from the &quot;work to do&quot; pool, atomically pledging that you may still <i>write</i> updates</li><li>Process the work unit</li><li>During processing, discover updates to <i>write</i> to the pool, and do so</li><li>End the processing of this work unit by ending the pledge</li></ol><p>This loop can also be done using the provided <code>work_while</code> function.</p><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>(!+'get, !-'write) t</span></span></code></div><div class="spec-doc"><p>A synchronizer with work units of type <code>'get</code> and updates of type <code>'write</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-init"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : 
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'get</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'write</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Condition.t <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'get</span>, <span class="type-var">'write</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Create a new synchronizer with the provided getter and writer (see module doc).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><span class="label">pledge</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'get</span>, <span class="type-var">'write</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'get</span> option</span></span></code></div><div class="spec-doc"><p>Get a work unit from the synchronizer. If pledge is true (its default value), atomically create a new pledge.</p><p>Blocks if no work unit is available but some may become in the future (i.e. there are still active pledges on the synchronizer has not been marked closed).</p><p>Returns None if no work unit is available and none will be in the future.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write"><a href="#val-write" class="anchor"></a><code><span><span class="keyword">val</span> write : <span><span class="type-var">'write</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'get</span>, <span class="type-var">'write</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Write the given update to the synchronizer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make_pledge"><a href="#val-make_pledge" class="anchor"></a><code><span><span class="keyword">val</span> make_pledge : <span><span><span>(<span class="type-var">'get</span>, <span class="type-var">'write</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Make a new pledge to the synchronizer (see module doc).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-end_pledge"><a href="#val-end_pledge" class="anchor"></a><code><span><span class="keyword">val</span> end_pledge : <span><span><span>(<span class="type-var">'get</span>, <span class="type-var">'write</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>End one pledge.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-close"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><span><span>(<span class="type-var">'get</span>, <span class="type-var">'write</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Mark the synchronizer closed.</p><p>The synchronizer will return None on every subsequent get that would otherwise block.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-work_while"><a href="#val-work_while" class="anchor"></a><code><span><span class="keyword">val</span> work_while : <span><span>(<span><span class="type-var">'get</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'write</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'get</span>, <span class="type-var">'write</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Run the provided closure on the synchronizer until the synchronizer is exhausted (i.e. it returns None).</p></div></div></div></body></html>
